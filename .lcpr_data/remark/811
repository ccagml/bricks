{"data":[{"name":"2022-11-29 13:40:33","id":1669700433969,"body":"双指针,可以在一个循环里,把右边更大的也算上\n想不到的结果是 左边数量 * 右边数量"},{"name":"2022-11-30 15:33:39","id":1669793619674,"body":"耗时14:36\n还算顺利?要是推结果 左边数量 * 右边数量,可能需要时间"},{"name":"2022-12-01 00:28:27","id":1669883307090,"body":"class Solution\n{\npublic:\n    int numSubarrayBoundedMax(vector<int> &nums, int left, int right)\n    {\n        stack<int> s_l;\n        stack<int> s_r;\n        int n = nums.size();\n        vector<int> vi_l(n, -1);\n        vector<int> vi_r(n, n);\n\n        for (int i = 0; i < n; i++)\n        {\n            while (s_l.size() > 0 && nums[s_l.top()] < nums[i])\n            {\n                s_l.pop();\n            }\n            vi_l[i] = s_l.size() > 0 ? s_l.top() : -1;\n            s_l.push(i);\n\n            while (s_r.size() > 0 && nums[s_r.top()] < nums[i])\n            {\n                vi_r[s_r.top()] = i;\n                s_r.pop();\n            }\n            s_r.push(i);\n        }\n\n        int reuslt = 0;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            if (nums[i] >= left && nums[i] <= right)\n            {\n                // std::cout << i << \":\" << vi_l[i] << \":\" << vi_r[i] << std::endl;\n\n                reuslt += (i - vi_l[i]) * (vi_r[i] - i);\n            }\n        }\n\n        return reuslt;\n    }\n};"},{"name":"2022-12-01 00:53:14","id":1669884794436,"body":"795耗时0:25:31\n思考乘法用了一会, 最大的数负责掌管左右的数量, (右边数+自己) * (左边数 + 自己)"}]}