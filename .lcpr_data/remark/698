{"data":[{"name":"2022-12-05 15:32:00","id":1670225520083,"body":"698耗时0:44:56\n调试了半天,莫名其妙又通了, 有个应该 写 c+1 写成c++\nclass Solution\n{\npublic:\n    unordered_map<int, bool> all;\n    int need = 0;\n    vector<int> nnn;\n\n    int set_bit_1(int x, int index)\n    {\n        x |= (1 << index);\n        return x;\n    }\n\n    void dfs(int cur_index, int cur_flag, int cur_value)\n    {\n        if (cur_index >= nnn.size())\n        {\n            return;\n        }\n        if (cur_value > need)\n        {\n            return;\n        }\n        int has_cur_flag = set_bit_1(cur_flag, cur_index);\n        int has_cur_value = cur_value + nnn[cur_index];\n\n        if (cur_value < need)\n        {\n            dfs(cur_index + 1, cur_flag, cur_value);\n        }\n        if (has_cur_value == need)\n        {\n            all[has_cur_flag] = true;\n        }\n        else if (has_cur_value < need)\n        {\n            dfs(cur_index + 1, has_cur_flag, has_cur_value);\n        }\n    }\n\n    vector<int> vi;\n    int value_need = 0;\n    int kkk;\n    bool get_result(int all_index, int cur_flag, vector<int> &vresult)\n    {\n        if (vresult.size() == kkk && cur_flag == value_need)\n        {\n            return true;\n        }\n        if (vresult.size() == kkk)\n        {\n            return false;\n        }\n        for (int i = all_index; i < vi.size(); i++)\n        {\n            int index_flag = vi[i];\n            if ((index_flag & cur_flag) == 0)\n            {\n\n                vresult.push_back(i);\n                bool temp = get_result(i + 1, (index_flag | cur_flag), vresult);\n                // std::cout << all_index << \":\" << cur_flag << \":i:\" << i << \"temp:\" << temp;\n                // print_vresult(vresult);\n                if (temp)\n                {\n                    return true;\n                }\n                vresult.pop_back();\n            }\n        }\n        return false;\n    }\n\n    void print_vresult(vector<int> &nums)\n    {\n        std::cout << \"[\";\n        for (int i = 0; i < nums.size(); i++)\n        {\n            std::cout << nums[i] << \",\";\n        }\n        std::cout << \"]\" << std::endl;\n    }\n    bool canPartitionKSubsets(vector<int> &nums, int k)\n    {\n        nnn = nums;\n        kkk = k;\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            sum += nums[i];\n            value_need = set_bit_1(value_need, i);\n        }\n        if (sum % k != 0)\n        {\n            return false;\n        }\n        need = sum / k;\n        dfs(0, 0, 0);\n        for (pair<int, bool> pib : all)\n        {\n            vi.push_back(pib.first);\n            // print_flag(pib.first);\n        }\n        vector<int> vresult;\n        return get_result(0, 0, vresult);\n    }\n\n    bool is_bit_1(int x, int index)\n    {\n        return ((1 << index) & (x));\n    }\n\n    void print_flag(int num)\n    {\n        std::cout << \"(\";\n        for (int i = 0; i < 20; i++)\n        {\n            if (is_bit_1(num, i))\n            {\n                std::cout << i << \",\";\n            }\n        }\n        std::cout << \",,\" << num << \"),\";\n    }\n};"}]}