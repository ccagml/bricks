{"data":[{"name":"2022-11-29 13:41:23","id":1669700483767,"body":"1. 前缀和\n2. 把前n个分成y组的最大和\n1题做一天 1:55:8"},{"name":"2022-11-30 16:06:20","id":1669795580937,"body":"耗时 31:17\n还算顺利, 没有缓存结果超时了"},{"name":"2022-12-03 11:29:19","id":1670038159674,"body":"813耗时0:21:39\n还算顺利 调试浮点除法用了六七分钟\nclass Solution\n{\npublic:\n    unordered_map<int, unordered_map<int, double>> cur_k_value;\n\n    double get_sum(vector<int> &pre, int left, int right)\n    {\n        int left_value = (left > 0) ? pre[left - 1] : 0;\n        int right_value = (right >= pre.size()) ? pre[pre.size() - 1] : pre[right];\n        return right_value - left_value;\n    }\n    double dfs(vector<int> &pre, int cur, int k)\n    {\n\n        // 还有的数量\n        double has = pre.size() - cur;\n        if (k > has)\n        {\n            return 0;\n        }\n        if (k == 1)\n        {\n            double bbb = get_sum(pre, cur, pre.size()) / has;\n            // std::cout << \"bbb(\" << cur << \"->\" << pre.size() << \"=\" << bbb << \")\";\n            return bbb;\n        }\n        // 从cur开始分k份最大值\n        if (cur_k_value[cur].count(k) > 0)\n        {\n            return cur_k_value[cur][k];\n        }\n\n        double result = 0;\n        for (int start = cur; start < pre.size(); start++)\n        {\n            double a = get_sum(pre, cur, start) / (start - cur + 1);\n            // std::cout << \"aaa(\" << cur << \"->\" << start << \"=\" << a << \")\";\n            double b = dfs(pre, start + 1, k - 1);\n            result = max(result, a + b);\n        }\n        // std::cout << \"从\" << cur << \"分\" << k << \"=\" << result << std::endl;\n        cur_k_value[cur][k] = result;\n        return result;\n    }\n\n    double largestSumOfAverages(vector<int> &nums, int k)\n    {\n        int n = nums.size();\n        vector<int> pre;\n        int sum = 0;\n        for (int num : nums)\n        {\n            sum += num;\n            pre.push_back(sum);\n        }\n        return dfs(pre, 0, k);\n    }\n};"}]}