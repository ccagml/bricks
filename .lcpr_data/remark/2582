{"data":[{"name":"2022-12-05 16:40:42","id":1670229642501,"body":"用时38:50 思路是对的\nclass Solution\n{\npublic:\n    int loop_min = 999999999;\n    int path_min = 999999999;\n\n    unordered_map<int, unordered_map<int, int>> uiuii;\n    unordered_map<int, int> um_flag;\n    void dfs(int cur, int fa, int cur_min)\n    {\n        um_flag[cur] = fa;\n        for (pair<int, int> sun : uiuii[cur])\n        {\n            int next = sun.first;\n            if (um_flag.count(next) > 0)\n            {\n                loop_min = min(loop_min, sun.second);\n            }\n            else\n            {\n                dfs(next, cur, min(cur_min, sun.second));\n            }\n        }\n    }\n\n    int minScore(int n, vector<vector<int>> &roads)\n    {\n        for (int i = 0; i < roads.size(); i++)\n        {\n            int a = roads[i][0];\n            int b = roads[i][1];\n            int c = roads[i][2];\n            uiuii[a][b] = c;\n            uiuii[b][a] = c;\n        }\n        // std::cout << \"1111111111111\" << std::endl;\n        dfs(1, 1, 99999999);\n\n        queue<pair<int, int>> qi;\n        unordered_map<int, int> in_min;\n        for (pair<int, int> end : uiuii[n])\n        {\n            int nextb = end.first;\n            int len = end.second;\n            if (in_min.count(nextb) < 1 || in_min[nextb] > len)\n            {\n                in_min[nextb] = len;\n                qi.push(end);\n            }\n        }\n\n        // std::cout << \"22222\" << std::endl;\n        while (qi.size() > 0)\n        {\n            pair<int, int> cur_top = qi.front();\n            qi.pop();\n            int cur_b = cur_top.first;\n            int cur_b_min = cur_top.second;\n            for (pair<int, int> next_ob : uiuii[cur_b])\n            {\n                int next_b = next_ob.first;\n                int next_b_len = next_ob.second;\n                if (next_b == 1)\n                {\n                    path_min = min(path_min, min(next_b_len, cur_b_min));\n                }\n                else if (in_min.count(next_b) < 1 || in_min[next_b] > min(next_b_len, cur_b_min))\n                {\n                    in_min[next_b] = min(next_b_len, cur_b_min);\n                    // std::cout << cur_b << \"->\" << next_b << \"=\" << in_min[next_b] << \"),\";\n                    qi.push({next_b, min(next_b_len, cur_b_min)});\n                }\n            }\n        }\n        return min(path_min, loop_min);\n    }\n};"}]}