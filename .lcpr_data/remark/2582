{"data":[{"name":"2022-12-05 16:40:42","id":1670229642501,"body":"用时38:50 \n// 思路1:路径最小 , 环最小\n// 思路2:并查集思路\nclass Solution\n{\npublic:\n    int loop_min = 999999999;\n    int path_min = 999999999;\n\n    unordered_map<int, unordered_map<int, int>> uiuii;\n    unordered_map<int, int> um_flag;\n    void dfs(int cur, int fa, int cur_min)\n    {\n        um_flag[cur] = fa;\n        for (pair<int, int> sun : uiuii[cur])\n        {\n            int next = sun.first;\n            if (um_flag.count(next) > 0)\n            {\n                loop_min = min(loop_min, sun.second);\n            }\n            else\n            {\n                dfs(next, cur, min(cur_min, sun.second));\n            }\n        }\n    }\n\n    int minScore(int n, vector<vector<int>> &roads)\n    {\n        for (int i = 0; i < roads.size(); i++)\n        {\n            int a = roads[i][0];\n            int b = roads[i][1];\n            int c = roads[i][2];\n            uiuii[a][b] = c;\n            uiuii[b][a] = c;\n        }\n        // std::cout << \"1111111111111\" << std::endl;\n        dfs(1, 1, 99999999);\n\n        queue<pair<int, int>> qi;\n        unordered_map<int, int> in_min;\n        for (pair<int, int> end : uiuii[n])\n        {\n            int nextb = end.first;\n            int len = end.second;\n            if (in_min.count(nextb) < 1 || in_min[nextb] > len)\n            {\n                in_min[nextb] = len;\n                qi.push(end);\n            }\n        }\n\n        // std::cout << \"22222\" << std::endl;\n        while (qi.size() > 0)\n        {\n            pair<int, int> cur_top = qi.front();\n            qi.pop();\n            int cur_b = cur_top.first;\n            int cur_b_min = cur_top.second;\n            for (pair<int, int> next_ob : uiuii[cur_b])\n            {\n                int next_b = next_ob.first;\n                int next_b_len = next_ob.second;\n                if (next_b == 1)\n                {\n                    path_min = min(path_min, min(next_b_len, cur_b_min));\n                }\n                else if (in_min.count(next_b) < 1 || in_min[next_b] > min(next_b_len, cur_b_min))\n                {\n                    in_min[next_b] = min(next_b_len, cur_b_min);\n                    // std::cout << cur_b << \"->\" << next_b << \"=\" << in_min[next_b] << \"),\";\n                    qi.push({next_b, min(next_b_len, cur_b_min)});\n                }\n            }\n        }\n        return min(path_min, loop_min);\n    }\n};"},{"name":"2022-12-14 14:30:43","id":1670999443426,"body":"2492耗时0:23:47\nclass Solution\n{\npublic:\n    unordered_map<int, unordered_map<int, int>> a_to_b;\n    int loop_min = 99999999;\n    int path_min = 99999999;\n\n    unordered_set<int> flag;\n    void dfs(int cur, int cur_min)\n    {\n        flag.insert(cur);\n        for (pair<int, int> next : a_to_b[cur])\n        {\n            int next_b = next.first;\n            if (flag.count(next_b) > 0)\n            {\n                loop_min = min(loop_min, min(cur_min, next.second));\n            }\n            else\n            {\n                dfs(next_b, min(cur_min, next.second));\n            }\n        }\n    }\n    int minScore(int n, vector<vector<int>> &roads)\n    {\n        for (vector<int> &r : roads)\n        {\n            a_to_b[r[0]][r[1]] = r[2];\n            a_to_b[r[1]][r[0]] = r[2];\n        }\n        dfs(1, loop_min);\n\n        unordered_map<int, int> in;\n        queue<pair<int, int>> qi;\n        qi.push({n, path_min});\n        while (qi.size() > 0)\n        {\n            pair<int, int> cur = qi.front();\n            qi.pop();\n            int node_a = cur.first;\n            int cur_path = cur.second;\n\n            for (pair<int, int> next : a_to_b[node_a])\n            {\n                int next_b = next.first;\n                int next_b_min = min(cur_path, next.second);\n                if (next_b == 1)\n                {\n                    path_min = min(path_min, next_b_min);\n                    continue;\n                }\n                if (in.count(next_b) < 1 || in[next_b] > next_b_min)\n                {\n                    in[next_b] = next_b_min;\n                    qi.push({next_b, next_b_min});\n                }\n            }\n        }\n\n        return min(loop_min, path_min);\n    }\n};"},{"name":"2022-12-14 16:31:15","id":1671006675323,"body":"并查集思路\nclass unionFind\n{\npublic:\n    unordered_map<int, int> quan;\n    unordered_map<int, int> fa;\n    unionFind(int n)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            quan[i] = 1e9;\n            fa[i] = i;\n        }\n    }\n    int get_fa_quan(int i)\n    {\n        return quan[get(i)];\n    }\n    void set_fa_quan(int i, int v)\n    {\n        quan[get(i)] = min(quan[get(i)], v);\n    }\n    int get(int i)\n    {\n        if (fa[i] == i)\n        {\n            return i;\n        }\n        fa[i] = get(fa[i]);\n        return fa[i];\n    }\n    void set(int a, int b)\n    {\n        int fa_id = get(a);\n        int fb_id = get(b);\n        int fa_quan_a = get_fa_quan(a);\n        int fa_quan_b = get_fa_quan(b);\n        if (fa_quan_a > fa_quan_b)\n        {\n            fa[fa_id] = fb_id;\n        }\n        else if (fa_quan_a == fa_quan_b && fa_id > fb_id)\n        {\n            fa[fa_id] = fb_id;\n        }\n        else\n        {\n            fa[fb_id] = fa_id;\n        }\n    }\n};\n\nclass Solution\n{\npublic:\n    unordered_map<int, unordered_map<int, int>> a_to_b;\n    int minScore(int n, vector<vector<int>> &roads)\n    {\n        unionFind *uf = new unionFind(n + 1);\n        for (vector<int> &r : roads)\n        {\n            a_to_b[r[0]][r[1]] = r[2];\n            a_to_b[r[1]][r[0]] = r[2];\n            uf->set_fa_quan(r[0], r[2]);\n            uf->set_fa_quan(r[1], r[2]);\n            uf->set(r[0], r[1]);\n        }\n        return uf->get_fa_quan(1);\n    }\n};"}]}