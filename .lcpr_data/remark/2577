{"data":[{"name":"2022-11-29 14:59:04","id":1669705144815,"body":"一个中心点, 确认左边第一个字符, 查找右边这个字符, 确认第二个字符, 查找右边第二个字符?\n可能是二分?先统计所有数字的位置?"},{"name":"2022-11-29 15:24:54","id":1669706694889,"body":"\n//超时\nclass Solution\n{\npublic:\n    int countPalindromes(string s)\n    {\n        int n = s.size();\n        unordered_map<int, vector<int>> ucvi(10);\n        for (int i = 0; i < s.size(); i++)\n        {\n            int cur = s[i] - '0';\n            ucvi[cur].push_back(i);\n        }\n        int result = 0;\n        for (int mid = 2; mid <= n - 1; mid++)\n        {\n            for (int left_first_index = mid - 1; left_first_index >= 1; left_first_index--)\n            {\n                // std::cout << \"[mid:\" << mid << \":\" << left_first_index << \"]\" << std::endl;\n                int left_fist = s[left_first_index] - '0';\n                // //第一个大于 i\n                auto right_first = std::upper_bound(ucvi[left_fist].begin(), ucvi[left_fist].end(), mid);\n\n                if (right_first != ucvi[left_fist].end())\n                {\n                    int right_first_index = std::distance(ucvi[left_fist].begin(), right_first);\n                    // std::cout << *right_first << \" at index \" << std::distance(ucvi[left_fist].begin(), right_first);\n                    for (int left_second_index = left_first_index - 1; left_second_index >= 0; left_second_index--)\n                    {\n                        int left_second = s[left_second_index] - '0';\n                        // std::cout << \"(\" << left_second << left_fist << s[mid] << \"|\" << left_second_index\n                        //           << \":\" << left_first_index << \":\" << mid\n                        //           << \")\" << std::endl;\n                        // 检查右边第二个\n                        for (int right_first_start = right_first_index; right_first_start < ucvi[left_fist].size(); right_first_start++)\n                        {\n                            int right_first_pos = ucvi[left_fist][right_first_start];\n                            auto right_second = std::upper_bound(ucvi[left_second].begin(), ucvi[left_second].end(), right_first_pos);\n                            if (right_second != ucvi[left_fist].end())\n                            {\n                                // 有找到\n                                // std::cout << left_second << left_fist << s[mid] << \":add : \" << (ucvi[left_second].size() - std::distance(ucvi[left_second].begin(), right_second));\n                                result += (ucvi[left_second].size() - std::distance(ucvi[left_second].begin(), right_second));\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                }\n            }\n        }\n\n        return result;\n    }\n};"},{"name":"2022-11-29 15:36:23","id":1669707383435,"body":"前面的思路不对是dp,用map还会超时,竟然要用数组生成"}]}